## mysql 规范

### 操作规范

- 在对大表做表结构变更时，如修改字段属性会造成锁表，并会造成从库延迟，从而影响线上业务，必须在凌晨0:00后业务低峰期执行，另统一用工具pt-online-schema-change避免锁表且降低延迟执行时间
- 禁止一个MySQL实例存放多个业务数据库，会造成业务耦合性过高，一旦出现问题会殃及池鱼，增加了定位故障问题的难度。通常采用多实例解决，一个实例一个业务库，互不干扰
- 禁止在主库上执行后台管理和统计类的功能查询，这种复杂类的SQL会造成CPU的升高，进而会影响业务
- 禁止在线上做数据库压力测试
- 使用InnoDB存储引擎。
  - 支持事务，行级锁，更好的恢复性，高并发下性能更好。
  - InnoDB表避免使用COUNT(*)操作，因内部没有计数器，需要一行一行累加计算，计数统计实时要求较强可以使用memcache或者Redis。
- 表字符集统一使用UTF8。不会产生乱码风险。
- 避免使用外键，外键用来保护参照完整性，可在业务端实现。外键会导致父表和子表之间耦合，十分影响SQL性能，出现过多的锁等待，甚至会造成死锁

### 设计规范

- 表必须有主键，例如自增主键。

  ​	这样可以保证数据行是按照顺序写入，对于SAS传统机械式硬盘写入性能更好，根据主键做关联查询的性能也会更好，并且还方便了数据仓库抽取数据。从性能的角度来说，使用UUID作为主键是个最不好的方法，它会使插入变得随机

- 用DECIMAL代替FLOAT和DOUBLE存储精确浮点数

- 使用TINYINT来代替ENUM类型。

  采用enum枚举类型，会存在扩展的问题，例如用户在线状态，如果此时增加了：5表示请勿打扰、6表示开会中、7表示隐身对好友可见，那么增加新的ENUM值要做DDL修改表结构操作了

- 字段长度尽量按实际需要进行分配，不要随意分配一个很大的容量

### 索引规范

- 索引不是越多越好，按实际需要进行创建。

  ​	索引是一把双刃剑，它可以提高查询效率但也会降低插入和更新的速度并占用磁盘空间。适当的索引对应用的性能至关重要，而且在MySQL中使用索引它的速度是极快的。遗憾的是，索引也有相关的开销。每次向表中写入时（如INSERT、UPDATEH或DELETE），如果带有一个或多个索引，那么MySQL也要更新各个索引，这样索引就增加了对各个表的写入操作的开销。只有当某列被用于WHERE子句时，才能享受到索引的性能提升的好处。如果不使用索引，它就没有价值，而且会带来维护上的开销。

- 查询的字段必须创建索引。 如：1、SELECT、UPDATE、DELETE语句的WHERE条件列；2、多表JOIN的字段

- 不在索引列进行数学运算和函数运算。无法使用索引，导致全表扫描。

- 不在低基数列上建立索引，例如‘性别’。

   有时候，进行全表浏览要比必须读取索引和数据表更快，尤其是当索引包含的是平均分布的数据集是更是如此。对此典型的例子是性别，它有两个均匀分布的值（男和女）。通过性别需要读取大概一半的行。在种情况下进行全表扫描浏览要更快

- 不使用%前导的查询，如like ‘%xxx’。 无法使用索引，导致全表扫描

  ```
  低效查询
    SELECT * FROM t WHERE name LIKE '%de%';
    ----->
    高效查询
    SELECT * FROM t WHERE name LIKE 'de%';
  ```

- 不使用反向查询，如 not in / not like。无法使用索引，导致全表扫描

- 避免冗余或重复索引。联合索引IX_a_b_c(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)，那么索引 (a) 、(a,b) 就是多余的。

### SQL设计规范

- 不使用SELECT *，只获取必要的字段。 

  - 消耗CPU和IO、消耗网络带宽；
  - 无法使用覆盖索引。

- 用IN来替换OR 

  ```
  低效查询
  SELECT * FROM t WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30;
  ----->
  高效查询
  SELECT * FROM t WHERE LOC_IN IN (10,20,30);
  ```

- 避免数据类型不一致。

   ```
  SELECT * FROM t WHERE id = '19';
  ----->
  SELECT * FROM t WHERE id = 19;
   ```

- 减少与数据库的交互次数

  ```
  INSERT INTO t (id, name) VALUES(1,'Bea');
  INSERT INTO t (id, name) VALUES(2,'Belle');
  INSERT INTO t (id, name) VALUES(3,'Bernice');
  ----->
  INSERT INTO t (id, name) VALUES(1,'Bea'), (2,'Belle'),(3,'Bernice');
  Update … where id in (1,2,3,4);
  Alter table tbl_name add column col1, add column col2;
  ```

  