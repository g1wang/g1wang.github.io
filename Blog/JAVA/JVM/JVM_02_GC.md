# JVM_02_GC(Garbage Collection)
[TOC]



## 对象可回收判断

### 引用计数算法
-  有引用加1，引用失效减1，为0回收。缺点：难以解决对象相互引用问题。
### 可达性分析算法
- 通过一系列的“GC Roots”的对象作为起点，从这些节点向下搜索，做过的路径成为引用链（Reference Chain）,
  当一个对象与引用链没有相连，就说明该对象不可达，即为可回收对象。
- GC Roots 对象包含
	- 虚拟机栈（栈帧中的本地变量表）中引用的对象
	- 方法区中静态属性引用的对象
	- 方法区中常量引用的对象
	- 本地方法栈中JNI引用的对象
### 对象引用及其生存周期
- 强引用：只要强引用还在，就不会被回收
- 软引用：内存溢出前回收
- 弱引用：下一次回收
- 虚引用：不影响生存时间

## GC算法
### 标记-清除算法（Mark-Sweep）
- 分为标记和清除两个阶段
- 缺点
	- 两个阶段效率都低
	- 空间不连续 ，导致频繁GC
### 复制算法
- 内存二等分，每一次只使用一边的内存，内存使用满后，将存活的对象复制到另一边。
- 缺点：内存浪费
- 适用于新生代

### 标记-整理算法
- 整理过程将存活的对象向一端移动，然后清理掉边界以外的内存
- 适用于老年代

### 分代收集算法
- 当前主流算法
- 根据对象存活周期将内存分块，一般将JAVA堆分为新生代和老年代
- 新生代回收率高，采用复制算法
- 老年代回收率低，采用标记-整理

## HotSpot
### HotSpot如何进入GC
#### 枚举根节点
-  通过 GCRoots 做可达性分析时，必须要求对象引用关系的一致性，导致GC得要停顿下来等待枚举根节点动作完成（Stop The World）
- 通过 OopMap 优化停顿时间
#### 安全点和安全区域
- 安全点选取：是否具有让程序长时间执行的特征
- 在安全点记录OoPMap
- 在安全点中断线程：GC需要中断线程时，不直接操作线程，而是设置一个标志位，各线程主动轮询这个标志位，自己中断
- 安全区域：解决短时间内线程拿不到CPU时间无法跑到安全点，自行中断的情况，安全区域指的是一段代码中，引用关系不会发生变化。

### HotSpot的垃圾回收器
#### young generation
##### Serial （单线程）
- (STW) 新生代采用复制算法
##### ParNew（多线程版的Serial）
- （STW） 新生代采用复制算法
- 更关注于缩短垃圾收集停顿时间
- 并行
##### Parallel scavenge
- （STW） 新生代采用复制算法
- 更关注于吞吐量，CPU的利用率
- 并行
#### tenured genneration
##### Serial Old（单线程）
- (STW) 标记-整理
##### parallel Old
- (STW) 标记-整理
- 更关注于吞吐量，CPU的利用率
- 并行
##### CMS(Concurrent Mark Sweep)
- 特点：并发收集、低停顿
- 初始标记：（STW）仅标记能直接关联的对象
- 并发标记：（concurrent）枚举根节点，GC Roots Tracing
- 重新标记：（STW）修正并发标记过程，初始标记<时间<<并发标记
- 并发清除：（concurrent）是清除
- 缺点
	- 面向并发设计，对CPU资源占用紧张，占用用户CPU时间
	- 标记-清除导致空间碎片，导致大对象没空间，导致fullGC，CMS的fullGC执行内存碎片整理时无法并发，停顿时间加长 

##### G1 (Garbage-First)
- 特点：并行并发 、分代收集、空间整里、可预测停顿
- 将JAVA堆分为多个大小相等的区域（region），仍保留新生代老年代的概念，但是不再物理隔离
- G1从整体看是标记-整理，局部（两个region）上是基于复制算法
- 可预测停顿：G1记录各个region垃圾堆的价值大小（回收释放的空间以及时间），优先回收价值大的region
- Remembered Set：避免全堆扫描。每个Region对应一个Remembered Set 。举个例子，RegionA内的引用类型数据ReferenceA发生写操作，ReferenceA所引用的对象B处于不同RegionB，则把相关引用信息记录在RegionB的Remembered Set，在GCRoots枚举范围内加入Remembered Set保证不对全堆扫描也不会有遗漏

##### G1 GC过程
- 初始标记:（STW）仅标记能直接关联的对象
- 并发标记:（concurrent）枚举根节点，GC Roots Tracing
- 最终标记:（STW）把Remembered Set Logs合并到Remembered Set，修正并发标记过程
- 筛选回收：根据每个region的回收价值排序，制定回收计划。


### 内存分配回收
- 对象优先在Eden分配，当eden空间不足发起MinorGC
	- MinorGC：发生在新生代，MinorGC发生频繁，回收快
	- MajorGC(FullGC): 发生在老年代，速度比minorGC慢十倍以上
- 大对象直接进入老年代
	- 大对象需要连续内存空间，没有的话会导致GC触发
	- xx:pretenureSizeThreshold,另大于这个阈值的对象直接进入老年代。 