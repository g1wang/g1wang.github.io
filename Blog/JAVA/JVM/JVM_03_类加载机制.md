# JVM_03_类加载机制
[TOC]



## 类加载过程

加载 - linking [验证-准备-解析] - 初始化 - 使用 - 卸载
### 加载
- 通过权限定名获取此类二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存生成一个代表的Java.lang.class 对象作为方法区这个类的各种数据访问入口
### 验证
- 文件格式验证
- 元数据验证（对字节描述信息分析）
- 字节码验证（对数据流和控制流分析）
- 符号引用验证（可达性分析）
### 准备
- 初始化类变量的内存分配并设置类变量的初始值

### 解析
- 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

### 初始化
- 类变量、静态语句（静态语句只能访问到定义在静态语句之前的变量）
- 在初始化阶段，虚拟机规范严格规定有且只有5种情况必须立即初始化
	- 遇到new、getstatic 、putstatic、invokestatic 4条字节码指令
	- java.lang.reflect反射调用
	- 初始化一个类，父类未初始化，需先初始化父类
	- jvm启动时，需要指定一个要执行的主类（包含main()方法的类）
	- 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，需要先触发其初始化

## 类加载器
### 类加载器类型
- 启动类加载器（Bootstrap ClassLoader）：加载虚拟机需要的类
- 扩展类加载器（Extension Classloader）
- 应用程序类加载器（Application Classloader）
### 双亲委派模型
- 启动类加载器 <=扩展类加载器<=应用程序类加载器<=自定义类加载器
- 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式

### 破坏双亲委派模型
- OSGi网状结构类搜索顺序
	- 以java.*开头的类，委派给父类加载器加载。
	- 委派列表名单为的类，委派给父类加载器加载。
	- Import列表中的类，委派给Export这个类的Bundle的类加载器加载。
	- 查找当前Bundle的Classpath，使用自己的类加载器加载
	- 查找是否存在自己的Fragment Bundle中，如果是则委派给Fragment Bundle的类加载器加载。
	- 查找Dynamic Import列表的Bundle，委派给对应的Bundle的类加载器加载。
	- 类查找失败 